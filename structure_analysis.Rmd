---
title: "Population Structure Analysis of PNG cohort"
author: "Stuart Lee"
date: "`r Sys.Date()`"
output: BiocStyle::html_document
---

```{r setup, include=FALSE}
pkgs <- c("starmie", "SeqArray", "dplyr", 
          "readr", "ggplot2", "knitr", "tidyr", "grid")
inst <- lapply(pkgs, library, character.only = TRUE)
opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE,
               fig.path = "./report_figures/", 
               cache.path = "./report_cache/",
               fig.align = 'center')
theme_set(theme_bw())
eval_run
```

# Introduction

After processing the PNG sequencing data as described in our previous [report](report.html), we obtained two variant callsets consisting of only the single clone isolates. The first callset contains the complete SNP set where the genotypes were constructed from B-allele frequency data where the SNPs were segregating in all three sampling sties. The second SNP set contains markers that are in linkage equilbrium only derived from the first callset. For more details about how this data set was constructed see our [selection report](selection_report.html).

```{r read_in, cache=TRUE}
input_file1 <- "cache/png_complete.str"
pf_snps_all <- read_delim(input_file, delim = " ", col_names = FALSE)
N1 <- nrow(pf_snps_all)
l1 <- ncol(pf_snps_all) - 3
input_file2 <- "cache/png_unlinked.str"
pf_snps_le <- read_delim(input_file2, delim = " ", col_names = FALSE)
N2 <- nrow(pf_snps_le)
l2 <- ncol(pf_snps_le) -3

```

The complete SNP set contains `l1` markers, while
the linkage equilbrium set has `r l2` markers. The counts per sampling site
segreate as follows,

```{r site}
pf_snps_le %>% count(X3)
```

We plot the missing genotype calls below (which we defined if the site coverage within sample was less than 5 bases) for the complete set below.

```{r missing_data, eval = FALSE, fig.cap="Bar plot of SNP missingess in each taxa."}
# work out proportion missingess in each SNP
# by_sample_missing <- pf_snps_recode %>% 
#   dplyr::select(Sample, starts_with("Pf")) %>% 
#   gather(snp, genotype, -Sample)  %>% 
#   count(Sample, genotype)
# 
# # create stacked bar plot
# missingness_bar <- ggplot(by_sample_missing, aes(x = Sample, y = n, fill = factor(genotype))) +
#   geom_bar(stat = "identity") + scale_y_continuous(expand = c(0,0)) + 
#   scale_fill_discrete("Genotype") +
#   theme(axis.text.x = element_blank(), panel.grid = element_blank())
# 
# missingness_bar
```


![Geography of PNG and surrounding regions.](./report_figures/PNGmap.png)

## Population Structure Inference (STRUCTURE)
We decided to run STRUCTURE using two different models
using our two different SNP sets:

1. the no-linkage, admixture only model
2. the correlated allele-frequencies, admixture model

For both model fitting procedures we used the following settings:

1. Run STRUCTURE with K= 1 up to 20 with 20 runs with different seeds.
2. Use an MCMC burn-in period of 10,000 iterations and total MCMC iterations up to 100,000.
3. Use inflection point in final estimated log-likelihood to determine optimal K and look at results of 'evanno' method.
4. Check MCMC diagnostics by looking at change in admixture parameter over MCMC runs.
5. After selecting K parameter, combined results using CLUMPAK algorithm.

All the following analysis and visualizations were performed in our new R package `starmie` (https://github.com/sa-lee/starmie).

```{r eval-structure}
# check if structure has been run 
not_run <- !file.exists("structure_runs_MAL192.rds")

# if we haven't stored results of structure run, run the pipeline.
# and extract data for structure.
if( not_run ) {
    # recode  NA to -9
    str_df <- pf_recode2
    str_df[is.na(str_df)] <- -9
    str_df <- str_df %>% dplyr::select(-Geographic)
    write.table(str_df, "MAL192.str", 
                quote = FALSE, row.names = FALSE, col.names = FALSE) 
} else {
    str_filelist <- readRDS("structure_runs_MAL192.rds")
}

```

```{r run_structure, child="run_structure.Rmd", eval=not_run}
```

```{r starmie-mcmc, fig.width=18, fig.height = 14}

# check MCMC diagnostics
mcmc_df <- do.call("rbind", lapply(1:400, 
                                   function(i) getMCMC(str_filelist[[i]])))

mcmc_df <- mcmc_df %>% group_by(K, Iteration) %>% 
    mutate(run = row_number()) %>% 
    filter(run <= 20)

ggplot(mcmc_df, 
       aes(x = Iteration, y = Alpha, colour = factor(run))) + 
    facet_grid(K ~., scales = "free_y") + geom_line()

```



From the MCMC diagnostic plots it appears that the admixture coefficient $\alpha$
is relatively stable over the chains for all $K$ values except in the case 
of $K = 1$ (where it doesn't really make sense.).

```{r starmie-mcmc2, fig.width=18, fig.height=14}
ggplot(mcmc_df, 
       aes(x = Iteration, y= LogL, colour = factor(run))) + 
    facet_grid(K ~., scales = "free_y") + geom_line() 

```

Similarly, the likelihood estimates appear to be relatively stable over the runs for 
each $K$, and the chains appear to have converged at the final iteration, 
although a longer burn-in  period is required for the $K > 10$ runs.


```{r logL}
best_k_strucutre <- bestK(str_filelist, "structure")

```

We estimate `best K` by simply plotting the log posterior probability of
the data for each $K$ and look for the inflection point in the curve. STRUCTURE
computes the estimated log posterior probability by taking the ratio of the mean 
estimated log-likelihood of the data and the estimated variance of the 
log-likelihood of  the data over all MCMC chains. We use the Evanno method to 
look at the change in log-likelihood for each $K$ over all runs. 


```{r evanno, fig.width = 12, fig.height=8}
# find 'best k'
best_k_evanno <- bestK(str_filelist, "evanno")
```

After inspection of the curves, $K$ = 8 looks like a reasonable estimate of
the number of sub-populations in the data. We then CLUMPP the results together
and plot the average ancestral membership coefficients over the runs by partitioning 
by the original  population label in the data set. 


## Session Information

```{r}
sessionInfo()
```
